"""
Test Internal Security logic for the analysis engine, including authentication and authorization of internal service requests, context management, and enforcement of tenant scope based on JWT tokens.

Copyright (c) 2026 Stefan Kumarasinghe

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
"""

import asyncio
import json
from pydantic import BaseModel
import jwt
from starlette.responses import JSONResponse

from services.security_service import (
    InternalAuthMiddleware,
    InternalContext,
    enforce_request_tenant,
    get_context_tenant,
    reset_internal_context,
    set_internal_context,
)
from config import settings


def _headers(payload):
    token = jwt.encode(payload, settings.context_verify_key, algorithm="HS256")
    return {
        "x-service-token": settings.expected_service_token,
        "authorization": f"Bearer {token}",
    }


def _set_security_defaults():
    settings.expected_service_token = "internal-service-token"
    settings.context_verify_key = "very-secret-signing-key"
    settings.context_issuer = "beobservant-main"
    settings.context_audience = "becertain"
    settings.context_algorithms = "HS256"


async def _run_request(path: str, headers: dict[str, str]):
    async def app(scope, receive, send):
        payload = {"tenant_id": get_context_tenant("spoofed-tenant")}
        response = JSONResponse(payload)
        await response(scope, receive, send)

    middleware = InternalAuthMiddleware(app)

    scope = {
        "type": "http",
        "asgi": {"version": "3.0"},
        "http_version": "1.1",
        "method": "GET",
        "scheme": "http",
        "path": path,
        "raw_path": path.encode("ascii"),
        "query_string": b"",
        "headers": [(k.encode("latin1"), v.encode("latin1")) for k, v in headers.items()],
        "client": ("127.0.0.1", 12345),
        "server": ("testserver", 80),
    }

    messages: list[dict] = []

    async def receive():
        return {"type": "http.request", "body": b"", "more_body": False}

    async def send(message):
        messages.append(message)

    await middleware(scope, receive, send)

    status = next(m["status"] for m in messages if m["type"] == "http.response.start")
    body = b"".join(m.get("body", b"") for m in messages if m["type"] == "http.response.body")
    data = json.loads(body.decode("utf-8")) if body else {}
    return status, data


def test_missing_service_token_rejected():
    _set_security_defaults()
    status, _ = asyncio.run(_run_request("/api/v1/tenant", headers={}))
    assert status == 401


def test_invalid_context_token_rejected():
    _set_security_defaults()
    status, _ = asyncio.run(
        _run_request(
            "/api/v1/tenant",
            headers={"x-service-token": settings.expected_service_token, "authorization": "Bearer invalid"},
        )
    )
    assert status == 401


def test_valid_context_enforces_tenant_scope():
    _set_security_defaults()
    headers = _headers(
        {
            "iss": settings.context_issuer,
            "aud": settings.context_audience,
            "iat": 1_700_000_000,
            "exp": 4_700_000_000,
            "tenant_id": "tenant-from-context",
            "org_id": "tenant-from-context",
            "user_id": "u1",
            "username": "alice",
        }
    )
    status, payload = asyncio.run(_run_request("/api/v1/tenant", headers=headers))
    assert status == 200
    assert payload["tenant_id"] == "tenant-from-context"


def test_enforce_request_tenant_overrides_payload():
    token = set_internal_context(
        InternalContext(
            tenant_id="ctx-tenant",
            org_id="ctx-tenant",
            user_id="u1",
            username="alice",
            permissions=[],
            group_ids=[],
            role="user",
            is_superuser=False,
        )
    )

    class Req(BaseModel):
        tenant_id: str
        start: int
        end: int

    try:
        req = Req(tenant_id="spoofed", start=1, end=2)
        scoped = enforce_request_tenant(req)
        assert scoped.tenant_id == "ctx-tenant"
    finally:
        reset_internal_context(token)
